### Diff


* 动态作用域在程序运行是只有一个env(env是一组identifer到value的binding)，在每次的函数求值时，只会在这个唯一的env里查询或更新。

* 而static scope是每次函数求值的时候都创建一个新的env，包含了函数定义时候的所能访问到的各种binding。这个新的env连同那个函数一起，俗称闭包Closure。


* 词法作用域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，去函数定义时的环境中查询。

* 动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，到函数调用时的环境中查。


* 词法作用域（静态作用域）是在书写代码或者说定义时确定的，而动态作用域是在运行时确定的。

* 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用，其作用域链是基于运行时的调用栈的。


* 我猜你可能混淆了LEGB Rule和Dynamic Scoping，他们相同的地方都是由内向外逐层检查变量的定义是否存，但是有闭包的lexical scoping是逐层向外检查Closure中变量是否存在，而dynamic scoping则是根据函数调用链逐层向外检查变量是否存在，哪怕函数的定义不是嵌套的。

### Dynamic scope

``` sh
num=1
function foo()
{
    echo $num;
}

function bar()
{
    local num=2;
    foo;
}

bar
```

bash为动态作用域，输出为2。

``` lisp
(setq f
      (let ((x 1))
        (lambda (y) (* x y))))

(let ((x 2))
  (funcall f 2))
```

emacs lisp为动态作用域，返回1*2

### Lexical scope(Static scope)

``` javascript
var num = 1;
function foo(){
    console.log(num);
}
!function(){
    var num = 2;
    static();
}();
```

因为javascript是词法作用域，static的scope在创建是，记录的foo是1，所以输出1而非2。如果是动态作用域，那么应该输出2。


``` python
def foo():
    print(num)

def bar():
    num = 2
    foo()

num = 1
bar()
```

python同为词法作用域，因此输出为1
