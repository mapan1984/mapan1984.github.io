### 同步与异步

针对**消息通信机制/被调用函数**，如果被调用函数在没有得到结果之前不返回，则为同步；如果调用函数直接返回，有结果时通过状态、消息来通知调用者，则为异步。

### 阻塞与非阻塞

针对**程序在等待调用结果（消息，返回值）时的状态/调用者**，如果调用者在调用函数后一直等待结果（线程挂起），则为阻塞(调用者在从调用函数开始到这个函数返回的整段时间内是被阻塞的)；如果调用者在调用之后不等待（不阻塞当前线程），而是定时查询有无结果返回，则为非阻塞。

### 异步IO

#### 轮询

异步执行的函数虽然直接返回，但为了使调用者可以得知函数的执行状态，函数一般会在执行完成之后设置特定的状态。而调用方需要重复进行状态判断。

比如调用者同时调用10个异步IO操作，这10个异步的IO操作对应10个状态，调用者需要在调用之后**轮询**这10个状态。当某一状态为真时，说明该异步IO执行完毕，调用者需要执行后续操作。这样可以得到比依次调用10个同步IO更高的效率。

但如果只执行一个异步IO操作，调用者实际上阻塞在**轮询**这一个IO操作对应的状态上，得不到比同步IO更高的效率。

``` c
// read
// select
// poll
// epoll
```
1. select。每个连接对应一个描述符（socket），循环处理各个连接，检查它的状态，ready了就进行处理，不ready就不进行处理。select有很多缺点：
    * 采用1024长度的数组存储状态，单个进程能够监视的文件描述符的数量存在最大限制
    * 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。
    * 需要维护一个用来存放大量数据的结构，这样会使得用户空间和内核空间在传递该结构时复制开销过大
2. poll。本质上和select没有区别，但是由于它是基于链表来存储的，没有最大连接数的限制。缺点是：
    * 大量的的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。
    * poll的特点是「水平触发(只要有数据可以读，不管怎样都会通知)」，如果报告后没有被处理，那么下次poll时会再次报告它。
3. epoll。利用事件通知，执行回调的方式，而不是遍历查询。进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它幻想，它使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。epoll支持水平触发和边缘触发，最大的特点在于「边缘触发」，它只告诉进程哪些刚刚变为就绪态，并且只会通知一次。使用epoll的优点很多：
    * 没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存上能监听约10万个端口）
    * 效率提升，不是轮询的方式，不会随着fd数目的增加效率下降
    * 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销

轮询满足了非阻塞IO确保获取完整数据的需求，但是应用程序仍需等待IO完成，在等待期间，CPU要么用于遍历文件描述符的状态(select, poll)，要么用于休眠等待事件发生(epoll)，在这期间任无法进行其他操作。

#### 多线程模拟

让一个线程(主线程)进行计算处理，其他线程通过阻塞IO或非阻塞IO加轮询技术完成数据获取，通过线程之间的通信将IO得到的数据进行传递，模拟实现异步IO。

#### 回调与事件循环

还有一种方法是在调用异步操作时绑定回调函数，并将异步操作完成后的状态与回调函数加入**事件队列**，然后不断取事件队列中的事件进行判断，如果满足则执行相应回调函数。

异步IO:

``` javascript
let fs = require('fs')

fs.readFile('/path', (err, file) => {
    console.log('读取文件完成')
})

console.log('发起读取文件')
```

绑定事件：

``` javascript
// server.js
let http = require('http')

http.createServer((req, res) => {
    let postData = ''

    req.on('data', (trunk) => {
        postData += trunk
    })

    req.on('end', () => {
        res.end(postData)
    })
}).listen(8080)

console.log('服务器启动完成')

// client.js
$.ajax({
    'url': '/url',
    'method': 'POST',
    'data': {},
    'success': (data) => {
        // success事件
    }
})
```

