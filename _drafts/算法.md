### 回溯法搜索子集树

``` c
void back_track(int t)
{
    if (t > n) {
        输出x;
    } else {
        for (i=0; i<=1; i++) {
            x[t] = i;
            if (constraint(t) && bound(t)) {
                back_track(t+1);
            }
        }
    }
}
```

### 回溯法搜索排列树

``` c
void back_track(int t)
{
    if (t > n) {
        输出x;
    } else {
        for (i=t; i<=n; i++) {
            swap(x[t], x[i]);
            if (constraint(t) && bound(t)){
                back_track(t+1);
            }
            swap(x[t], x[i]);
        }
    }
}
```

### 贪心算法

* 可贪心选择性:(第一次)做出的贪心选择是正确的
* 最优子结构:(第一次)贪心选择之后，得到与原问题定义相同，输入不同的子问题

### 动态规划

使用递归树求解子问题，从叶子结点(基本问题)起，向上求解

* 最优子结构:每一个问题的最优解包含子问题的最优解
* 重复子问题
