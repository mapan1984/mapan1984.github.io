### 分治

1. 分解(Divide)：将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。
2. 解决(Conquer)：递归的求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。
3. 合并(Combine)：将子问题的解组合成原问题的解。

### 贪心算法

* 贪心选择性：(第一次)做出的贪心选择是正确的
* 最优子结构：(第一次)贪心选择之后，得到与原问题定义相同，输入不同的子问题

### 动态规划

使用递归树求解子问题，从叶子结点(基本问题)起，向上求解

* 最优子结构：每一个问题的最优解包含子问题的最优解
* 重叠子问题

### 回溯法搜索子集树

``` c
void back_track(int t)
{
    if (t > n) {
        输出x;
    } else {
        for (i=0; i<=1; i++) {
            x[t] = i;
            if (constraint(t) && bound(t)) {
                back_track(t+1);
            }
        }
    }
}
```

### 回溯法搜索排列树

``` c
void back_track(int t)
{
    if (t > n) {
        输出x;
    } else {
        for (i=t; i<=n; i++) {
            swap(x[t], x[i]);
            if (constraint(t) && bound(t)){
                back_track(t+1);
            }
            swap(x[t], x[i]);
        }
    }
}
```
