{% highlight scheme linenos %}
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1 -- CONS" m))))
  dispatch)

(define (car z) (z 0))

(define (cdr z) (z 1))
{% endhighlight %}

    z = cons(1, 2)
    car(z)
    1
    cdr(z)
    2
    l = cons(z, 3)
    car(car(l))
    1
    
变量作用域: Local > Enclosing > global > build-in

`cons`函数中，`x, y`未在函数内部(local)，外部(global)定义，也不是解释器内置的变量(build-in)，`x, y`的作用域即为Enclosing，

Closure: 内部函数中对enclosing作用域的变量进行引用

在`cons`函数中，定义函数`dispatch`，`dispatch`引用了`x, y`，并且作为cons的返回值，当`cons`执行完成之后，虽然会对内部变量回收，但`dispatch`作为返回值，保留了`x, y`，的引用

`car`以`dispatch`的函数类型为参数时，内部调用`(dispatch 0)`，并返回其执行结果，即为`(cons x y)`中的`x`，同理`(cdr dispatch)`返回`y`

所以，我认为闭包就是一个函数被当作值返回时，相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性。

本来执行过程和词法作用域是封闭的，这种返回的函数就好比是一个虫洞.

显然，闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包。

*词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中*

{% highlight python linenos %}
#!/usr/bin/env python
# coding=utf-8
def cons(x, y):
    def dispatch(m):
        if m == 0:
            return x
        elif m == 1:
            return y
        else:
            print("Argument not 0 or 1 -- CONS",m)
    return dispatch

def car(z):
    return z(0)

def cdr(z):
    return z(1)
{% endhighlight %}

1.装饰器用来装饰函数
2.返回一个函数对象
3.被装饰函数标识符指向返回的函数对象
4.语法糖 @deco
