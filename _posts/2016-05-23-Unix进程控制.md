---
title: Unix进程控制
categories: [Unix]
tags: [C]
---

#### 获取进程ID

每个进程都有唯一的进程ID(PID为正数)，`getpid`返回调用它的进程的PID，`getppid`返回它的父进程的PID。

``` c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```
`pid_t`在Linux系统上在`types.h`中定义为`int`

#### 创建和终止进程

``` c
#include <stdlib.h>
void exit(int status);
```

``` c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

父进程通过调用`fork`来创建一个新的子进程，新创建的子进程得到与父进程用户级虚拟地址空间**相同但独立**的一份拷贝(包括文本，数据和bss段，堆栈以及用户栈)，子进程还获得与父进程任何打开文件描述符相同的拷贝，这意味着子进程可以读写父进程中打开的任何文件。父子进程的最大区别在于他们有不同的PID。

`fork`函数调用一次，但返回两次，一次在父进程，一次在新创建的子进程。在父进程中，`fork`返回子进程的PID(任何PID都为正数)，在子进程中，`fork`返回为0(这样做的理由是，一个父进程可以`fork`出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用`getppid()`就可以拿到父进程的ID)。

``` c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main(){
    int ppid=getpid();
    printf("Process (%d) start....\n", ppid);
    int cpid=fork();
    if(cpid == 0){
        printf("I am child process (%d) and my parent is (%d).\n", getpid(), getppid());
        exit(1);
    }else{
        printf("I (%d) just created a child process (%d).\n", getpid(), cpid);
    }
    return 0;
}

```

输出:

    Process (12792) start....
    I (12792) just created a child process (12308).
    I am child process (12308) and my parent is (12792).

有了`fork`调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就`fork`出子进程来处理新的http请求。

#### 回收子进程

``` c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
pid_t wait(int *status);
```
