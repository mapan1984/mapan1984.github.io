---
title: 递归与迭代
categories: [Program]
tags: [scheme]
---

### 递归与迭代

我们一般认为递归为定义函数时使用了自己，而迭代是循环，但这可能是不清晰的，甚至是错误的。比如下面定义的`+`，其在定义时都递归的调用了自己:

``` scheme
(define (+ x y)
    (if ( = x 0)
        y
        (+ (-1 x) (+1 y))))


; 运用代换模型

(+ 3 4)
(+ 2 5)
(+ 1 6)
(+ 0 7)
7
```

我们可以看到，虽然采用了递归的定义，但其在实际运算时，会在函数调用的最后一层直接返回，而不会回到上一层调用自己的函数，和循环结构有相同的时间复杂和空间复杂度(time=O(x); space=O(1))。

``` scheme
(define (+ x y)
    (if (= x 0)
        y
        (+1 (+ (-1 x) y)))

; 运用代换模型

(+ 3 4)
(+1 (+ 2 4))
(+1 (+1 (+ 1 4)))
(+1 (+1 (+1 (+ 0 4))))
(+1 (+1 (+1 4)))
(+1 (+1 5))
(+1 6)
7
```

而这次，同样采用递归的定义，其在实际运算时，函数一层一层调用，最后一层会返回给自己的上一层，在第一层返回，其时间复杂度time=O(x)，空间复杂度space=O(x)。

综上，递归与迭代的区别不在于定义方式，而在于其实际运行时，嵌套的函数在结束时是否直接返回值，如果直接返回，则为迭代；如果返回值给其上一层同名函数，则为递归。

### 尾递归

实际上，尾递归优化可以使尾递归调用在常量空间内做迭代计算。（William Clinger博士在Compiler Optimization for Symbolic Languages中引征Guy Steel的话：“并不是函数调用造成压栈，是参数求值造成压栈。”）

普通的递归:

``` scheme
(define (factorial x)
    (if (= x 0) 
        1
        (* x (factorial x-1))))

(factorial 3)
(* 3 (factorial 2))
(* 3 (* 2 (factorial 1)))
(* 3 (* 2 (* 1 (factorial 0))))
(* 3 (* 2 (* 1 1)))
(* 3 (* 2 1))
(* 3 2)
6
```

尾递归优化:

``` scheme
(define (factorial n)
    (define (iter n x)
        (if (= n 0) 
            x
            (iter (- n 1) (* x n))))
    (iter n 1))

(factorial 3)
(iter 3 1)
(iter 2 3)
(iter 1 6)
(iter 0 6)
6
```
