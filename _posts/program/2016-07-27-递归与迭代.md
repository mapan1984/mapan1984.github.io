---
title: 递归与迭代
categories: [Program]
tags: [scheme]
---

### 1.递归与迭代

当我们说一个过程是递归的时候，论述的是一个语法形式上的事实，说明这个过程的定义中(直接或间接地)引用了该过程本身。

但递归定义可以产生不同的计算过程，比如下面定义的`+`，其在定义时都递归的调用了自己:

``` scheme
(define (+ x y)
    (if ( = x 0)
        y
        (+ (-1 x) (+1 y))))


; 运用代换模型

(+ 3 4)
(+ 2 5)
(+ 1 6)
(+ 0 7)
7
```

我们可以看到，虽然采用了递归的定义，但其在实际运算时，会在函数调用的最后一层直接返回，而不会回到上一层调用自己的函数，和循环结构有相同的时间复杂和空间复杂度(time=O(x); space=O(1))。

``` scheme
(define (+ x y)
    (if (= x 0)
        y
        (+1 (+ (-1 x) y)))

; 运用代换模型

(+ 3 4)
(+1 (+ 2 4))
(+1 (+1 (+ 1 4)))
(+1 (+1 (+1 (+ 0 4))))
(+1 (+1 (+1 4)))
(+1 (+1 5))
(+1 6)
7
```

而这次，同样采用递归的定义，其在实际运算时，函数一层一层调用，最后一层会返回给自己的上一层，在第一层返回，其时间复杂度time=O(x)，空间复杂度space=O(x)。

综上，计算过程是否为递归或迭代不在于定义方式，递归的定义也可以产生迭代的运行过程，其区别在于:

1. 实际运行时，递归调用的函数在结束时是否直接返回值，如果直接返回，则为迭代计算过程；如果返回值给其上一层函数，则为递归计算过程。
2. 迭代的运行过程的每一层函数都会保存有得出结果的所有状态，而迭代的计算过程还存在一些”隐含“的信息。

### 2.尾递归

尾递归是编程语言实现的一种特性，这个特性为可以在常量空间内执行迭代计算过程，即使这以计算过程是用一个递归过程描述的。具有这一特性的实现称为尾递归的。

所以我们可以写出递归定义的迭代计算过程，但如果语言的实现没有对尾递归进行优化，得到的过程在每一次调用时申请新的栈空间，而不是像循环一样更新原有值。

实际上，尾递归优化可以使尾递归调用在常量空间内做迭代计算。（William Clinger博士在Compiler Optimization for Symbolic Languages中引征Guy Steel的话：“并不是函数调用造成压栈，是参数求值造成压栈。”）

普通的递归:

``` scheme
(define (factorial x)
    (if (= x 0)
        1
        (* x (factorial x-1))))

; 运用代换模型

(factorial 3)
(* 3 (factorial 2))
(* 3 (* 2 (factorial 1)))
(* 3 (* 2 (* 1 (factorial 0))))
(* 3 (* 2 (* 1 1)))
(* 3 (* 2 1))
(* 3 2)
6
```

尾递归版本:

``` scheme
(define (factorial n)
    (define (iter n x)
        (if (= n 0)
            x
            (iter (- n 1) (* x n))))
    (iter n 1))

; 运用代换模型

(factorial 3)
(iter 3 1)
(iter 2 3)
(iter 1 6)
(iter 0 6)
6
```

所以我们是否可以使用尾递归，还得看所用语言得实现是否为尾递归进行优化。
