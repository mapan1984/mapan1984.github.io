---
title: Unix系统级IO
categories: [Unix]
tags: [C]
---

### Unix I/O

一个Unix文件就是一个m个字节的序列，所有的I/O设备(如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当作相应文件的读和写来执行。这种将设备映射为文件的方式，允许Unix内核引出一个简单、低级的应用接口，称为Unix I/O，这使得输入和输出都能以一种统一且一致的方式执行:

* 打开文件: 一个应用程序通过要求内核打开相应的文件，来宣告它想访问一个I/O设备。内核返回一个小的非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。**内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。**
* 改变当前文件的位置: 对于每个打开的文件，内核保持着一个文件位置k，厨师为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行`seek`操作，显式的设置文件的当前位置为k。
* 读写文件: 一个读写就是从文件拷贝n个字节到存储器(n>0，存储器一般只程序中的字符数组)，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读写会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。**在文件结尾处并没有明确的`EOF`符号**。类似的，写操作就是从存储器拷贝n个字节到一个文件，从当前文件位置k开始，然后更新k。
* 关闭文件: 当应用完成了对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因而终止时，内核都会关闭所有打开的文件并释放它们的存储器资源。

### 打开和关闭文件

进程通过调用`open`来打开一个已存在文件或创建一个新文件

``` c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// 成功返回文件描述符，若失败，则返回-1
int open(char *filename, int flags, mode_t mode);
```

`open`将`filename`转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。

1. `flags`指明了进程打算如何访问这个文件，`flags`的参数可以是一个或更多为掩码的或，为写停供一些额外的提示。
    * `O_RDONLY`: 只读
    * `O_WRONLY`: 只写
    * `O_RDWR`: 可读可写
    * `O_CREAT`: 如果文件不存在，就创建它的一个截断的(truncated)(空)文件
    * `O_TRUNC`: 如果文件已经存在，就截断它
    * `O_APPEND`: 在每次写之前，设置文件位置到文件的结尾处(append，以追加方式写)

``` c
fd = open("foo.txt", o_rdonly, 0); // 以只读方式打开一个已存在文件
fd = open("foo.txt", o_wronly|o_append, 0); // 打开一个已存在文件，并在后面添加一些数据
```

2. `mode`指定了新文件的访问权限位。**作为上下文的一部分，每个进程都有一个`umask`，它是通过调用`umask`函数来设置的**。当进程通过带某个`mode`参数的`open`函数调用来创建一个新文件时，文件的访问权限位被设置为`mode & ~umask`。
    * `S_IRUSR`
    * `S_IWUSR`
    * `S_IXUSR`
    * `S_IRGRP`
    * `S_IWGRP`
    * `S_IXGRP`
    * `S_IROTH`
    * `S_IWOTH`
    * `S_IXOTH`

``` c
/* 
 * 创建新文件，文件拥有者有读写权限，而其他用户都有读权限
 */
#define DEF_MODE S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
#define DEF_UMASK S_IWGRP|S_IWOTH

umask(DEF_UMASK); // 设置进程的umask
fd = open("foo.txt", O_CREAT|O_TRUNC|O_WRONLY, DEF_MODE); // mode & ~umask
```

最后，进程通过调用`close`关闭一个打开的文件。

``` c
#include <unistd.h>

int close(int fd); // 成功返回0， 失败返回-1
```

关闭一个已关闭的描述符会出错。

### 读和写文件

应用程序时通过分别调用`read`和`write`来执行读和写的。

``` c
#include <unistd.h>

// 成功返回读的字节数，若EOF则为0，若出错返回-1
ssize_t read(int fd, void *buf, size_t n);

// 成功返回写的字节数，若出错则为1
ssize_t write(int fd, const void *buf, size_t n);
```
`read`从描述符为`fd`的当前文件位置拷贝至多`n`个字节到存储器位置`buf`。`write`从存储器位置`buf`拷贝至多`n`个字节到描述符`fd`的当前文件位置。

*`size_t`被定义为`unsigned int`，而为在出错时返回-1，`ssize_t`被定义为`int`。返回-1的可能性使得`read`的最大值减小一半，从4GB减小到2GB*

在某些情况下，`read`和`write`传送的字节比应用程序要求的少。这些**不足值**(short count)不表示错误。出现这种情况的原因如下:

* 读时遇到EOF: 假设我们准备读一个文件，该文件从当前位置开始只含有20个字节，而我们以50个字节的片进行读取。这样一来，下一个`read`返回的不足值为20，此后的`read`将通过返回不足值0来发出EOF信号。
* 从终端读文本行: 如果打开的文件是与终端相关联的(如键盘和显示器)，那么每个`read`函数将一次传送一个文本行，返回的不足值等于文本行的大小。
* 读和写网络套接字(socket):

### 读取文件元数据

应用程序能够通过调用`stat`和`fstat`函数，检索到关于文件的信息。

``` c
#include <unistd.h>
#include <sys/stat.h>

// 成功返回0，失败返回-1
int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
```

`stat`已文件名作为输入，`fstat`以文件描述符作为输入，调用它们都会填写如下所示的一个`stat`数据结构中的各个成员。

``` c
/* Metadata returned by the stat and fstat function */
struct stat {
    dev_t st_dev; /* Device */
    ino_t st_ino; /* inode */
    mode_t st_mode; /* Protection and file type */
    nlink_t st_nlink; /* Number of hard link */
    uid_t st_uid; /* User ID of owner */
    gid_t st_gid; /* Group ID of owner */
    dev_t st_rdev; /* Device type (if inode device) */
    off_t st_size; /* Total size, in bytes */
    unsigned long st_blksize; /* Blocksize for filesystem I/O */
    unsigned long st_blocks; /* Number of blocks allocated */
    time_t st_atime; /* Time of last access */
    time_t st_mtime; /* Time of last modification */
    time_t st_mtime; /* Time of last change */
}
```

`st_size`包含了文件的字节数大小。

`st_mode`则编码了文件访问许可位(同`read`函数的`mode`参数)和文件类型。Unix识别大量不同文件类型。

* 普通文件: 包含某种类型的二进制或文本数据。对内核而言，文本文件和二进制文件毫无区别。
* 目录文件: 包含关于其他文件的信息。
* 套接字: 是一种用来通过网络和其他进程通信的文件。

Unix提供的宏指令根据`st_mode`来确定文件的类型:

* `S_ISREG()`: 是普通文件吗？
* `S_ISDIF()`: 是目录文件吗？
* `S_ISSOCK()`: 是一个网络套接字吗？
