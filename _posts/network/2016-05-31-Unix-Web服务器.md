---
title: Unix Web服务器
categories: [network]
tags: [C, Unix]
---

### Web基础

Web客户端和服务器的交互用的是一个基于文本的应用级协议 —— HTTP(Hypertext Transfer Protocol)。HTTP是一个简单的协议。一个Web客户端(即浏览器)打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。

Web与常规的文件检索服务(如FTP)的主要区别是: Web内容可以使用HTML(Hypertext Markup Language)来编写，提供格式和布局的控制，并且包含超链接。

### Web内容

对于Web客户端和服务器而言，内容是与一个MIME(Multipurpose Internet Mail Extensions)类型相关的字节序列。

Web服务器以两种不同的方式向客户端提供内容:

1. 取一个磁盘文件，并将它的内容返回个客户端。
2. 运行一个可执行文件，并将它的输出返回个客户端。

每条有Web服务器返回的内容都是和它管理的的某个文件相关联的。这些文件中的每一个都有唯一的名字，叫做URL(Universal Resource Locator)。例如:

    http://www.google.com:80/index.html

标识因特网主机www.google.com上一个称为/index.html的HTML文件，它是由一个监听端口80的Web服务器管理的。

可执行文件的URL可以在文件名后包括程序参数。`?`分隔文件名和参数，而且每个参数都用`&`分隔开。例如:

    http://example.com:80/cig-bin/adder?123&345

标识了一个叫做/cig-bin/adder的可执行文件，会带两个参数123和345来调用它。在事务过程中，客户端和服务器使用的URL的不同部分。例如，客户端使用前缀

    http://www.google.com:80

来决定与哪类服务器联系，服务器在哪，以及它监听的端口号是多少。服务器使用后缀

    /index.html

来发现在它的文件系统中的文件，并确定请求的是动态内容还是静态内容。

### HTTP事务

HTTP事务是指由客户端发起HTTP请求，服务器返回HTTP响应，然后关闭连接。

#### 1.HTTP请求

HTTP请求的组成:

1. 一个请求行(request line)
2. (紧跟着)零个或多个请求报头(request header)
3. (最后以)一个空的文本行来终止报头列表

*每个文本行都由一对回车和换行符结束`\r\n`*

请求行的形式是:

    <method> <uri> <version>

\<method\>是HTTP支持的方法，包括GET、POST、OPTIONS、HEAD、PUT、DELETE和TRACE。应用最多的GET方法指导服务器生成和返回\<URI\>(Uniform Resource Identifier)标识的内容。URI是相应URL的后缀，包括文件名和可选的参数。\<version\>表明了该请求遵循的HTTP版本。

请求报头为服务器提供了额外的信息，例如浏览器的商标名，或者浏览器理解的MIME类型。请求报头的格式为:

    <header name>: <header data>

针对HTTP/1.1请求，我们需要HOST报头，如`Host: www.google.com`，它的数据指示了原始服务器的域名。

#### 2.HTTP响应

HTTP响应的组成:

1. 一个响应行(response line)
2. (紧跟着)零个或更多的响应报头(response header)
4. (在紧跟着)一个终止报头的空白行
5. (再紧跟着)一个响应主体(response body)

一个响应行的格式是:

    <version> <status code> <status message>

\<version\>描述了响应所遵循的HTTP版本。\<status code\>是一个三位的正整数，指明对请求的处理，\<status message\>给出与错误码等价的英文描述。以下是一些常见的状态码:

<table class="table table-bordered table-hover">
    <tr>
        <th>Status Code</th> <th>Status Message</th> <th>描述</th>
    </tr>
    <tr>
        <td>200</td>         <td>成功</td>           <td>处理请求无误</td>
    </tr>
    <tr>
        <td>301</td>         <td>永久移动</td>       <td>内容已移至位置头指明的主机上</td>
    </tr>
    <tr>
        <td>400</td>         <td>错误请求</td>       <td>服务器不能理解请求</td>
    </tr>
    <tr>
        <td>403</td>         <td>禁止</td>           <td>服务器无权访问请求的文件</td>
    </tr>
    <tr>
        <td>404</td>         <td>未发现</td>         <td>服务器找不到所请求的文件</td>
    </tr>
    <tr>
        <td>501</td>         <td>未实现</td>         <td>服务器不支持请求的方法</td>
    </tr>
    <tr>
        <td>505</td>         <td>HTTP版本不支持</td> <td>服务器不支持请求的版本</td>
    </tr>
</table>

响应报头提供了关于响应的附加信息。比如`Content-Type`告诉客户端响应主体中内容的MIME类型；`Content-Length`指示响应主体的大小。

终止响应报头的空文本行之后，跟随的响应主体，响应主体中包含着被请求的内容。

### 服务动态内容

CGI(Common Gateway Interface)的实际标准用来解决如下问题:

1. 客户端如何将参数传递给服务器

    Get请求的参数在URL中传递。一个`?`分割文件名和参数，而每个参数都用一个`&`字符隔开。参数中不允许有空格，而必须用字符串`%20`来表示，对于其他特殊字符，也存在着相似的编码。POST请求的参数是在请求主体中而不是在URI中传递的。

2. 服务器如何将参数传递给子进程

    在服务器接收到一个如下的请求后
        
        GET /cgi-bin/adder?123&345 HTTP/1.1
     
    它调用`fork`创建一个子进程，并调用`execve`在子进程的上下文中执行`/cgi-bin/adder`程序。像`adder`这样的程序，常常被称为CGI程序，因为它们遵守CGI标准。在调用`execve`之前，子进程将CGI环境变量`QUERY_STRING`设置为`123&345`，`adder`程序在运行时可以使用Unix `getenv`函数来引用它。

3. 服务器如何将其他信息传递给子进程

    CGI定义了大量的环境变量，一个CGI程序在它运行时可以设置这些环境变量。

    <table class="table table-bordered table-hover">
        <tr>
            <th>环境变量</th>       <th>描述</th>
        </tr>
        <tr>
            <td>QUERY_STRING</td>   <td>程序参数</td>
        </tr>
        <tr>
            <td>SERVER_PORT</td>    <td>父进程监听的端口</td>
        </tr>
        <tr>
            <td>REQUEST_METHOD</td> <td>GET或POST</td>
        </tr>
        <tr>
            <td>REMOTE_HOST</td>    <td>客户端的域名</td>
        </tr>
        <tr>
            <td>REMOTE_ADDR</td>    <td>客户端的点分十进制IP地址</td>
        </tr>
        <tr>
            <td>CONTENT_TYPE</td>   <td>只对POST而言: 请求体的MIME类型</td>
        </tr>
        <tr>
            <td>CONTEMT_LENGTH</td> <td>只对POST而言: 请求体的字节大小</td>
        </tr>
    </table>

4. 子进程将它的输出发送到哪里

    一个CGI程序将它的动态内容发送到标准输出。在子进程中加载并运行CGI程序之前，它使用Unix `dup2`函数将标准输出重定向到和客户端相关联的已连接描述符。因此，任何CGI程序写到标准输出的内容都会直接到达客户端。
    因为父进程不知道子进程生成的内容的类型和大小，所以子进程负责生成`Content-type`和`Content-length`响应报头，以及终止报头的空行。
