---
title: Unix网络编程
tags: [C, Unix]
---

### 网络基础

IP地址是一个32bits无符号整数。网络程序将IP地址存放在IP地址结构中:

``` c
/* Internet address structure */
struct in_addr{
    unsigned int s_addr; /* Network byte order (big-endian) */
};
```

因为因特网主机可以有不同的主机字节顺序，TCP/IP为任意整数数据项定义了统一的网络字节顺序(network byts order)(big-endian)，Unix提供了下面这样的函数在网络和主机字节顺序间实现转换:

``` c
#include <netinet/in.h>

// 返回按照网络字节顺序的值
unsigned long int htonl(unsigned long int hostlong); // 32bits IP地址
unsigned short int htons(unsigned short int hostshort); // 16bits 端口号

// 返回按照主机字节顺序的值
unsigned long int ntohl(unsigned long int netlong);
unsigned short int ntohs(unsigned short int netlong);
```

IP地址通常以点分十进制来表示，每个字节有它的十进制表示，并用句点和其他字节分开。因特网程序使用`inet_aton`和`inet_ntoa`函数实现IP地址和点分十进制串之间的转换:

``` c
#include <arpa/inet.h>

// 成功返回1，失败返回0
// 点分十进制串cp --> struct in_addr *inp
int inet_aton(const char *cp, struct in_addr *inp);

// 成功返回指向点分十进制串的指针
char *inet_ntoa(struct in_addr in);
```

因特网定义了域名集合与IP地址集合之间的映射，这个映射通过DNS来维护。从概念上而言，DNS数据库有上百万个如下所示的**主机条目结构**(host entry structure)组成，其中每条定义了一组域名(一个官方名字和一组别名)和一组IP地址间的映射。

``` c
/* DNS host entry structure */
struct hostent {
    char *h_name; // Official domain name of host
    char **h_aliases; // Null-terminated arrar of domain names
    int h_addrtype; // Host address type (AF_INET)
    int h_length; // Length of an address, in bytes
    char **h_addr_list; // Null-terminated array of in_addr structs
}
```

*注意其将IP地址结构体当做字符串，我猜这样做可能是因为需要按字节大小出来IP地址*

因特网应用程序通过调用`gethostbyname`和`gethostbyaddr`函数，从DNS数据库中检索任意的主机条目。

``` c
#include <netdb.h>

// 成功返回非NULL指针，若出错返回NULL指针，同时设置h_errno
struct hostent *gethostbyname(const char *name); // 注意 name 是域名，不是点分十进制串
struct hostent *gethostbyaddr(const char *addr, int len, 0);
```

*返回结构体指针，结构体不会在函数返回时销毁吗，返回指针怎么可用，说明结构体不是在函数内部声明创建的，或结构体是malloc在堆中创建的*

### 套接字接口


      Client process                 Server process 

         socket                         socket
           |                              |
           |                              |
           |                              v
           |                             bind
           |                              |
           |                              |
           |                              v
           |                            listen
           |                              |
           |                              |
           v      Connection request      v
        connect ----------------------> accept <-------------------------------------------+
           |                              |                                                ^
           |                              |                                                |
           |                              |                                                |
           v     Client sends requset     v    Server processes request   ____________     |
         write ========================> read ==========================> | Resource |     |
           |                              |        and requset source     |__________|     |
           |                              |                               |__________|     |
           |                              |                               |__________|     |
           |                              |                              //                |
           |                              |        +====================+                  |
           v    Server sends respense     v       // get the sorce file                    |
         read <======================== write <==+                                         |
           |                              |                                                |
           |                              |                                                |
           v            EOF               v                                                |
         close ------------------------> read                                              |
                                          |                                                |
                                          v     Await connection request from next client  |
                                         close ------------------------------------------->+

从Unix程序的角度来看，套接字就是一个有相应描述符的打开文件。因特网的套接字地址存放在如下所示的类型为`sockaddr_in`的16bytes结构中。

``` c
/* Generic socket address structure (for connect, bind, and accept) */
struct sockaddr{
    unsigned short sa_family; // Protocol family
    char sa_data[14]; // Address data
}

/* Internet-style socket address structure */
struct sockaddr_in{
    unsigned short sin_family; // Address family (always AF_INET)
    unsigned short sin_port; // Port number in network byte order
    struct in_addr sin_addr; // IP address in network byte order
    unsigned char sin_zero[8]; // Pad to sizeof(struct sockaddr)
}
```

客户端和服务器使用`socket`函数来创建一个套接字描述符(socket descriptor)。

``` c
#include <sys/types.h>
#include <sys/socket.h>

// 成功返回非负描述符，失败返回-1
int socket(int domain, int type, int protocol);
```

``` c
/* 
 * 创建一个套接字描述符
 * AF_INET 表明我们正在使用因特网
 * SOCK_STREAM 表明这个套接字是用于因特网连接的一个端点
 */

socketfd = socket(AF_INET, SOCK_STREAM, 0);
```

`socket`返回的套接字描述符仅是部分打开的，还不能用于读写。如何完成打开套接字的工作，取决于我们是客户端还是服务器。  
客户端通过调用`connect`函数来建立和服务器的连接:

``` c
#include <sys/socket.h>

// 若成功返回0，出错返回-1
int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
```

`connect`函数试图与套接字地址为`serv_addr`的服务器建立一个因特网连接，其中`addrlen`是`sizeof(sockaddr_in)`。`connect`函数会阻塞，一直到连接成功建立或是发生错误。如果成功，`sockfd`描述符现在就准备好读写了，即使用Unix I/O函数与服务器通信。  包装`socket`和`connect`为`open_clientfd`:

``` c
/*
 * 创建socket描述符并与运行在hostname上的服务器(知名端口)建立一个连接
 * 若成功则返回一个打开的套接字描述符
 * 若Unix出错则返回-1
 * 若DNS出错则返回-2
 */

typedef struct sockaddr SA;   // Generic socket address structure

int open_clienfd(char *hostname, int port){
    int clientfd;
    struct hostent *hp;
    struct sockaddr_in serveraddr;

    if((clientfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
        return -1; // Check errno for cause of error
    }

    /* Fill in the server's IP address and port */
    if((hp = gethostbyname(hostname)) == NULL){
        return -2; // Check h_errno for cause of error
    }
    bzero((char *)&serveraddr, sizeof(serveraddr));
    serveraddr.sin_family = AF_INET;
    bcopy((char *)hp->h_addr_list[0], (char *)&serveraddr.sin_addr.s_addr, hp->h_length);
    serveraddr.sin_port = htons(port);

    /* Establish a connection with the server */
    if(connect(clientfd, (SA *)&serveraddr, sizeof(sockaddr_in)) < 0){
        return -1;
    }
    return clientfd;
}
```

服务器使用`bind`、`listen`、`accept`和客户端建立连接。

``` c
#include <sys/socket.h>

// 成功返回0，失败返回-1
int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
int listen(int sockfd, int backlog);
```
`bind`函数告诉内核将`my_addr`中的服务器套接字地址和套接字描述符`sockfd`联系起来，参数`addrlen`是`sizeof(sockaddr_in)`。  
`listen`函数将`sockfd`从一个主动套接字转换为一个**监听套接字**(listening socket)，该套接字可以接受来自客户端的连接请求。`backlog`参数暗示了内核在开始拒绝连接请求之前，应该放入队列中等待的未完成连接请求的数量。  将`socket`、`bind`、`listen`组合为`open_listenfd`:

``` c
/*
 * 打开和返回一个监听描述符，这个描述符准备好在知名端口port上接收连接请求
 * 若成功返回描述符
 * 若Unix出错返回-1
 */

#define LISTENQ 1024
typedef struct sockaddr SA;   // Generic socket address structure

int open_listenfd(int port){
    int listenfd, optval=1;
    struct sockaddr_in serveraddr;

    /* Create a socket descriptor */
    if((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
        return -1;
    }

    /* 
     * Eliminates "Address already in use" error from bind 
     * 使服务器可以立即终止和重启，默认地，一个重启的服务器将
     * 在大约30秒内拒绝客户端的连接请求
     */
    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, 
               (const void *)&optval, sizeof(int)) < 0){
        return -1;
    }

    /* Listenfd will be an end point for all requsts to port
       on any IP address for this host */
    bzero((char *)&serveraddr, sizeof(serveraddr);
    serveraddr.sin_family = AF_INET;
    serveraddr.sin_addr.saddr = htonl(INADDR_ANY); // INADDR_ANY表示这台主机的任何IP
    serveraddr.sin_port = htons((unsigned short)port);
    if(bind(listenfd, (SA *)&serveraddr, sizeof(serveraddr)) < 0){
        return -1;
    }

    /* Make it a listening socket ready to accept connection requests */
    if(listen(listenfd, LISTENQ) < 0){
        return -1;
    }
    return listenfd;
}
```

服务器通过调用`accept`函数来等待来自客户端的连接请求。

``` c
#include <sys/socket.h>>

// 成功则返回非负描述符，出错返回0
int accept(int listenfd, struct sockaddr *addr, int *addrlen);
```

`accept`函数等待来自客户端的连接请求到达监听描述符`listenfd`，然后在`addr`中填写客户端的套接字地址，并返回一个**已连接描述符**(connected desctptor)，这个描述符可被用来利用Unix I/O函数与客户端通信。
