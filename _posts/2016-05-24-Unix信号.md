---
title: Unix信号
categories: [Unix]
tags: [C]
---

Linux支持30种不同类型的信号(输入`man 7 signal`查看)，每种信号都对应于某种系统事件。信号提供一种机制，通知进程发生了异常，底层的硬件异常由内核异常处理程序处理。但系统提供的函数使一个进程可以显式的发送信号，也可以通过修改和信号相关联的默认行为，按我们的需求处理特定信号。

传送一个信号到目的进程由两个不同步骤组成:

1. 发送信号: 内核通过更新目的进程的上下文中的某个状态，**发送**一个信号给目的进程。发送信号可以有如下两个原因:
    * 内核检测到一个系统事件，比如被零除错误(内核发送`SIGFPE`给试图除以0的进程)或者子进程终止(内核发送`SIGCHLD`给父进程)。
    * 一个进程调用`kill`函数，显式的要求内核发送一个信号给目的进程(一个进程可以给自己发送信号)。

2. 接收信号: 当一个进程被内核强迫**以某种方式对信号的发送做出反应时**，目的进程就**接收**了信号。进程可以忽略这个信号，终止或通过执行一个被称为**信号处理程序(signal handler)**的用户层函数捕获这个信号。

一个只发出而没有被接收的信号称为**待处理信号(pending signal)**。在任何时刻，一种类型的待处理信号至多只有一个，如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的待处理信号都不会排队等待，而是被简单的丢弃。

一个进程可以有选择的**阻塞**接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收(处理)，直到进程取消对这种信号的阻塞。

### 发送信号

#### 1.进程组

每个进程都只属于一个**进程组**，进程组都是由一个正整数**进程组ID**来标识的。`getpgrp`返回当前进程的的进程组ID。

``` c
#include <unistd.h>
pid_t getpgrp(void);
```
默认地，一个进程和它的父进程同属于一个进程组。一个进程可以通过使用`setpgid`来改变自己或其他进程的进程组:

``` c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
```
`setpgid`将进程`pid`的进程组改为`pgid`。如果`pid`是0，那么就使用当前进程的PID。如果`pgid`为0，那么就用`pid`指定的进程PID作为进程组ID。

#### 2.用kill函数发送信号

进程通过`kill`发送信号给其他进程(包括它们自己)

``` c
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
```
1. 如果`pid>0`，那么`kill`发送信号`sig`给进程`pid`。
2. 如果`pid<1`, 那么`kill`发送信号`sig`给进程组`abs(pid)`。

进程可以通过`alarm`向它自己发送`SIGALRM`信号

``` c
#include <unistd.h>
unsigned int alarm(unsigned int secs);
```

`alarm`会安排内核在`secs`秒内发送一个`SIGALRM`信号给调用进程。

### 接收信号

``` c
#include <signal.h>
typedef void(*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
```
