---
title: Unix异常
categories: [Unix]
tags: [C, ASM]
---

#### Unix异常

当应用程序需要请求内核服务(例如读文件`read`，创建进程`fork`,终止进程`exit`或加载新程序`execve`)时，就需要使用系统调用。系统调用对程序员来说就像使用函数调用一样，我们可以简单的理解其为一种提供程序到内核的像函数一样的接口。

系统调用本身是一种有意的异常，处理器提供了`syscall n`指令，用户想请求服务`n`时，可以执行这条指令(`n`为异常号)，这将导致一个到异常处理程序的陷阱，这个处理程序对参数进行解码，并调用适当的内核程序。

Linux提供了上百种系统调用，为了使用系统调用，在IA32系统上，(*用户程序必须通过系统调用接口间接的访问内核代码和数据*)系统调用通过一条`int n`的陷阱指令来提供(`int`为`interrupt`，系统调用的异常好通常为128`0x80`，所以指令为`int $0x80`)。

C语言可以通过`syscall`函数直接调用任何系统调用，但C标准库提供了一组包装函数，这些包装函数将参数打包到一个以适当系统调用号陷入内核，然后将系统的返回状态传递回调程序。

#### 使用`int $0x80`系统调用

用C提供的系统函数写的hello程序，`write`的参数问文件描述符，字节序列，字节数

``` c
int main(){
    write(1, "hello, world\n", 13);
    exit(0);
}
```

下面是汇编版本，使用`int`指令来调用`write`和`exit`系统调用，系统调用的参数通过寄存器来传递，`%eax`传递系统调用号(对应一个到内核中跳转表的偏移量)，`%ebx, %ecx, %edx, %esi, %edi, %ebp`可以包含最多六个任意参数(`%esp`不能使用，因为进入内核态时，内核会覆盖它)

``` asm
  .section data
string:
    .ascii "hello, world\n"
string_end:
    .equ len, string_end - string
    
  .section .text
  .globl main
main:
  # First, call write(1, "hello, world\n", 13)
  movl $4, %eax      # system call number 4
  movl $1, %ebx      # stdout has descriptior 1
  movl $string, %ecx # hello world sting
  movl $len, %edx    # string length
  int $0x80          # system call code

  # Next, call exit(0)
  movl $1, %eax      # system call number 1
  movl $0, %ebx      # Argument is 0
  int $0x80
```
