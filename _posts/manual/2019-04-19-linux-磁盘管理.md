---
title: Linux 磁盘管理
tags: [Linux]
---

## 磁盘，块设备，磁盘分区，文件系统

当磁盘(disk) 挂载到 Liunx 系统时，它只是一个块设备，虽然 Linux 也将其映射为一个 `/dev/` 下的存储设备文件，但是其和我们通常说的文件系统文件不是一回事。

比如磁盘对应的存储文件为 `/dev/vdb`，你可打开、读取、写入这个设备文件，但是这时的访问单元是块，而且只能指定地址去访问块数据，得到的是磁盘上存储的原始数据，而无法按文件系统的方式去组织数据，比如无法做在 `/dev/vdb` 下新建目录，在目录中新建文件，指定路径访问文件等操作。

我们一般说的文件，其实是文件系统的抽象概念，文件系统在块设备之上，对用户更加友好。文件系统按目录组织文件，实际上内容还是存储在块设备上，当读写文件系统文件时，文件系统也是通过指定地址读取块设备，只不过文件系统除了文件本身的内容外，会额外存储关于文件组织的元信息，比如目录、权限等信息。

不同文件系统有不同组织方式，比如 linux 上常见的 ext4 和 xfs 文件系统。空白的块设备需要经过格式化，组织并写入文件系统需要预设置的内容，才可以按该文件系统的方式访问。

`mount` 命令将格式化后的存储设备，按照格式化使用的文件系统类型，挂载到全局目录树的一个路径节点上，之后我们才能通过这个路径，访问并读写这个存储设备上文件系统下的文件。

磁盘分区可以在逻辑上将一个磁盘设备切分成多个设备，一个磁盘上不同的分区都可以看作是不同的设备，磁盘分区本身不是必须做的。

## 添加新硬盘

添加新硬盘的整体流程为：

1. 通过 `fdisk -l` 查看磁盘设备
2. **可选** 使用 `fdisk` 对磁盘设备划分逻辑分区
3. 使用 `mkfs` 格式化/创建文件系统
4. 将设备挂载到目录

### 查看磁盘设备信息

列出当前系统中所有的硬盘设备及其分区信息：

    $ fdisk -l
    Disk /dev/vda: 20 GiB, 21474836480 bytes, 41943040 sectors
    Units: sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    Disklabel type: dos
    Disk identifier: 0x013315e2

    Device     Boot Start      End  Sectors Size Id Type
    /dev/vda1  *     2048 41943006 41940959  20G 83 Linux


    Disk /dev/vdb: 50 GiB, 53687091200 bytes, 104857600 sectors
    Units: sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    Disklabel type: dos
    Disk identifier: 0x3cd16b5a

    Device     Boot Start       End   Sectors Size Id Type
    /dev/vdb1        2048 104857599 104855552  50G 83 Linux

各列的含义：

* Disk: 硬盘的设备文件名
* Device: 分区的设备文件名称（Device 是从 Disk 创建的分区）
    * Boot: 是否为引导分区
    * Start: 该分区在硬盘中的起始位置（柱面数）
    * End: 该分区在硬盘中的结束位置（柱面数）
    * Blocks/Sectors: 分区的大小，以 Blocks 为单位（默认为 1024 bytes）
    * Id: 分区的类型 ID 标记（对于 ext3 分区为 83，LVM 分区为 8e）
    * System/Type: 分区类型

#### 其他相关命令

* `lsblk`: 查看设备文件类型，容量，挂载点等信息
* `blkid`: 查看设备文件 UUID，块大小，文件系统等信息。

### 创建磁盘分区 fdisk

**磁盘分区不是必须创建** 的，比如我们有磁盘设备 `/dev/vdb`，我们可以直接对 `/dev/vdb` 做文件系统。

进入交互的分区管理界面，在硬盘设备中创建、删除、更改分区：

    $ fdisk <硬盘设备文件名>

常用交互操作指令有：

* m: 打印操作指令的帮助信息
* p: 打印分区信息
* n: 新建分区
* d: 删除分区
* t: 变更分区类型/更改分区的系统 ID
* l: 列出已知的分区类型

* w: 保存分区设置并退出
* q: 放弃分区设置并退出

* b: 编辑 bsd disklabel
* c: 切换 dos 兼容性标志

* g: 创建一个新的空 GPT 分区表
* G: 创建一个 IRIX（SGI）分区表
* o: 创建一个新空 DOS 分区表
* s: 创建一个新的空的 Sun 磁盘标签

* u: 更改显示/输入单位
* v: 验证分区表
* x: 额外功能

如果我们要创建磁盘分区，先输入 `n`，根据提示进行选择，结束后输入 `l` 查看创建分区信息，最后输入 `w` 保存分区设置并退出。

### 格式化/创建文件系统 mkfs

格式化并创建文件系统：

    $ mkfs.ext4 <设备文件名>

`mkfs` 有不同文件系统支持，例如：

    $ mkfs.ext4 /dev/sdb1

    $ mkfs.xfs /dev/sdb1

### 挂载文件系统到目录 mount/umount

将设备文件格式化为文件系统后，需要将设备文件 「挂载」到全局目录树的节点上，才能通过这个节点路径，访问存储设备中的目录、文件等数据。

    $ mount [-t 类型] <存储设备> <挂载点目录>

使用不带任何参数或选项的 `mount` 命令时，将显示出当前系统中已挂载的各个文件系统的相关信息。

`proc`、`sysfs`、`tmpfs` 等文件系统是 Linux 运行所需要的临时文件系统，并没有实际的硬盘分区与其相对应，因此也称为 「伪文件系统」。例如 `proc` 映射了内存及 cpu 寄存器中的部分数据。

`/etc/fstab` 文件包含了开机后自动挂载的文件记录，可视为 `mount` 命令的配置文件。其中存储了文件系统的静态挂载数据。Linux 系统每次开机时，会自动读取这个文件的内容，自动挂载所指定的文件系统。

在 `/etc/fstab` 文件中，每一行记录对应一个分区或设备的挂载配置信息，从左到右包括六个字段（使用空格或制表符分隔），各部分的含义如下所述：

* 第一字段：设备名或设备卷标名。
* 第二字段：文件系统的挂载点目录的位置。
* 第三字段：文件系统类型，如 `ext4`, `swap` 等。
* 第四字段：挂载参数，即 `mount` 命令 `-o` 选项后可使用的参数，如 `defaults`、`rw` 等。
* 第五字段：表示文件系统是否需要 dump 备份，一般设为 1 时表示需要，设为 0 时将被 dump 所忽略。
* 第六字段：该数字用于决定在系统启动时进行磁盘检查的顺序，0 表示不进行检查，1 表示优先检查，2 表示其次检查。对于根分区应设为 1，其他分区设为 2.

例如：

| 磁盘设备 | 挂载点目录 | 文件系统 | 挂载选项         | dump 选项 | fsck 选项 |
|----------|------------|----------|------------------|-----------|-----------|
| /dev/sdb | /data1     | ext4     | defaults,noatime | 0         | 0         |


`umount` 命令取消挂载关系：

    $ umount <挂载点目录>

如果出现 `device is busy` 错误，表示该文件系统正在被使用，可以用以下命令查看使用文件系统的进程：

    $ fuser -m <挂载点目录>
    $ lsof <挂载点目录>

## LVM(Linux Volume Manager)

### 基本概念

* PV（Physical Volume，物理卷）：通常对应为一个普通分区或整个硬盘，是 LVM 机制的基本存储设备。创建物理卷时，会在分区或硬盘的头部创建一个保留区块，用于记录 LVM 的属性，并把存储空间分割成默认大小为 4MB 的基本单元 PE，从而构成物理卷。物理卷一般直接使用设备文件名称，如 `/dev/sdb1`、`/dev/sdb2` 等。用于转换成物理卷的普通分区，建议先使用 `fdisk` 工具将分区类型的 ID 标记号改为 “8e”。若是整块硬盘，可以将所有磁盘空间划分为一个主分区后再作相应调整。
* VG（Volume Group，卷组）：由一个或多个物理卷组成一个整体，即成为卷组，在卷组中可以动态地添加或移除物理卷。许多个物理卷可以分别组成不同的卷组，卷组名称由用户自行定义。
* LV（Logical Volume，逻辑卷）：逻辑卷是建立在卷组之上的，与物理卷没有直接关系。对于逻辑卷来说，每一个卷组就是一个整体，从这个整体中 “切出” 一小块空间，作为用户创建文件系统的基础，这一小块空间就称为逻辑卷。使用 mkfs 等工具在逻辑卷上创建文件系统以后，即可挂载到 Linux 系统中的目录下使用。

通过上述对物理卷、卷组、逻辑卷的解释可以看出，建立 LVM 分区管理机制的过程就是：

1. 首先，将普通分区或整个硬盘创建为物理卷；
2. 接下来，将物理上比较分散的各物理卷的存储空间组成一个逻辑整体，即卷组；
3. 最后，基于卷组这个整体，分割出不同的数据存储空间，形成逻辑卷。而逻辑卷才是最终用户可以格式化并挂载使用的存储单位。

### 管理命令

| 功  能       | 物理卷管理 | 卷组管理  | 逻辑卷管理 |
|--------------|------------|-----------|------------|
| Scan  扫描   | pvscan     | vgscan    | lvscan     |
| Create 建立  | pvcreate   | vgcreate  | lvcreate   |
| Display 显示 | pvdisplay  | vgdisplay | lvdisplay  |
| Remove 删除  | pvremove   | vgremove  | lvremove   |
| Extend 扩展  |            | vgextend  | lvextend   |
| Reduce 减少  |            | vgreduce  | lvreduce   |

主要命令的语法：

    $ pvcreate [--dataalignment 512k] /dev/sdb
    $ vgcreate <vgname>  物理卷名1 物理卷名2
    $ lvcreate -L 大小 -n <vgname> <lvname>
    $ lvextend -L 大小 -f /dev/<vgname>/<lvname>
    $ lvreduce -L 大小 -f /dev/<vgname>/<lvname>
    $ lvremove -f /dev/<vgname>/<lvname>
    $ vgs
    $ vgs --units G
    $ lvs

创建的 vg 在 `/dev` 下，创建的 lg 在 `/dev/<vg_name>` 下

