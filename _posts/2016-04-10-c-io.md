---
layout: post 
title: c io 
categories: [linux]
tags: [c]
---

### 打开流

{% highlight c linenos %}
FILE *fopen(char const *name, char const *mode);
{% endhighlight %}

mode的选项:  r w a rb rw ra a+

return: `FILE *` or `NULL`
    
使用:

{% highlight c linenos %}
FILE *input;
input = fopen("file", "r");
if(input == NULL){
    perror("can not open file");
    exit(EXIT_FAILURE);
}
{% endhighlight %}

以指定文件名和模式重新打开 stream:

{% highlight c linenos %}
FILE *freopen(char const *filename, char const *mode, FILE *stream);
{% endhighlight %}

return: `FILE *stream` or `NULL`

### 关闭流

{% highlight c linenos %}
int fclose(FILE *f);
{% endhighlight %}

return: `0` or `EOF`

使用:

{% highlight c linenos %}
if(fclose(input) != 0){
    perror("fclose %s", input);
    exit(EXIT_FAILURE);
}
{% endhighlight %}

### 字符i/o

{% highlight c linenos %}
int fgetc(FILE *stream);
int getc(FILE *stream);
int getchar(void);
{% endhighlight %}

return: 函数执行成功会返回读取的字符，失败返回EOF

*不用char作为返回值类型的原因是为了返回EOF(end of file)，EOF作为常量，它的值在任何可能出现的字符范围之外*

---

{% highlight c linenos %}
int fputc(int character, FILE *stream);
int putc(int character, FILE *stream);
int putchar(int character);
{% endhighlight %}

return: `0` or `EOF` 

在写入流之前，character 会被剪裁为无符号字符型值

*getc, putc, getchar, putchar是通过#define定义的宏*

---

{% highlight c linenos %}
int ungetc(int character, FILE *stream);
{% endhighlight %}

`ungetc`把一个先前读入的字符返回的流中，这样它可以在以后被重新读入  比如:

{% highlight c linenos %}
/*
** 从一串标准输入中读取的数字转化为整数
*/
#include <stdio.h>
#include <ctype.h>

int read_int(){
    int value;
    int ch;
    value = 0;

    while((ch = getchar()) != EOF && isdigit(ch)){
        value *= 10;
        value += ch - '0';
    }

    // 把非数字字符退回的流中，这样它不会丢失
    ungetc(ch, stdin);
    return value;
}
{% endhighlight %}

---

### 未格式化的行i/o

{% highlight c linenos %}
// stream ==> buffer
char *fgets(char *buffer, int buffer_size, FILE *stream);
char *gets(char *buffer);
{% endhighlight %}

当`fgets`读取到一个换行符并存储的buffer之后就不再读取，如果buffer中的字符数达到buffer_size-1时它也停止读取，任何情况下，NUL字节会被添加到buffer所存储数据的末尾.

*`fgets`无法把字符读入到长度小于两个字符的buffer，因为其中一个字符需要为NUL字节保留* 

return: 如果在任何字符读取前就到达了文件末尾，`fgets`会返回NULL, 否则返回buffer

`gets`读取一行输入时，并不在buffer中存储结尾的换行符

---

{% highlight c linenos %}
// buffer ==> stream
int fputs(char const *buffer, FILE *stream);
int puts(char const *buffer);
{% endhighlight %}

return: 执行错误返回EOF，否则返回非负值 

传递个fputs的buffer预期以NUL结尾，buffer中可以有换行符(\r\n)，即可以一次写入多行

`puts`写入一个字符串时，它在字符串写入之后向输出在添加一个换行符

### 格式化的行i/o

{% highlight c linenos %}
// stream ==> ...
int fscanf(FILE *stream, char const *format, ... );
int scanf(char const *format, ... );
int sscanf(char const *string, char const *format, ... );
{% endhighlight %}

每个原型中的省略号表示一个可变长度的指针列表，从输入转换而来的值逐个存储到这些指针指向的内存地址

{% highlight c linenos %}
// ... ==> stream
int fprintf(FILE *stream, char const *format, ... );
int printf(char const *format, ... );
int sprintf(char *buffer, char const *format, ... );
{% endhighlight %}

### 二进制i/o

{% highlight c linenos %}
size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream);
{% endhighlight %}

return: 函数返回实际读取或写入的元素(而非字节)数目，如果输入过程中遇到了EOF或输出过程中出现错误，这个数字可能比请求的元素数目小。

### 刷新和定位函数

{% highlight c linenos %}
int fflush(FILE *stream);
{% endhighlight %}

fflush迫使一个输出流的缓冲区内的数据进行物理写入，不管它是否已经写满。

在程序调试时可以用来在特定位置输出信息，即使程序执行崩溃

{% highlight c linenos %}
printf("something or other");
fflush(stdout);
{% endhighlight %}

---

{% highlight c linenos %}
long ftell(FILE *stream);
int fseek(FILE *stream, long offset, int from);
{% endhighlight %}

ftell返回流的当前位置，即下一个读取或写入将要开始的位置距离文件起始位置的偏移量。在二进制流中，这个之就是当前位置距离文件起始位置之间的字符数，在文本流中，它不一定准确的表示当前位置和文本起始位置之间的字符数(因为有些系统将对行末字符进行翻译转换)，但ftell的返回值总是可以用于fseek中，作为一个距离文件起始位置的偏移量。
