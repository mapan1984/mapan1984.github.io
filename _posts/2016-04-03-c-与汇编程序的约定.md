---
layout: post 
title: C 与汇编程序的约定调用
categories: [linux]
tags: [C, asm]
---

## 说明

### 执行函数前（已经调用）(prologue)：

将参数逆序压入堆栈(这样在使用`esp+偏移量`来访问参数时，可以不考虑参数的数量，直接用`%esp+8(,%esp+12...)`等访问第1个至第N个参数)

`pushl $3                  # push the n  parameter`

`pushl $2                  # push the secondary parameter`

`pushl $1                  # push the first parameter`

`call fun                  # `
    
    参数n
    .
    .
    .
    参数(3)：
    参数(2)：  
    参数(1)：  
    返回地址：                  <----esp 


### 执行函数(body)：

保存原来的`ebp`至堆栈中

`pushl %ebp`

    .
    参数3：
    参数2：  
    参数1：
    返回地址：
    %ebp(原)                    <----esp

将现在的`ebp`赋值为`esp`

`movl %esp,%ebp`

    参数3：
    参数2：
    参数1：      
    返回地址：                                            
    %ebp(原)                    <----esp  <----ebp

创建空间(下移`esp`指针)用于保存局部变量

`subl $8,%esp`

    参数3：
    参数2：     
    参数1：           
    返回地址：            
    %ebp(原)                    <----ebp        
    |  
    |                           <----esp

### 返回(epilogue)：

保存返回值至`eax`

`movl -n(%ebp), %eax`

丢弃创建的空间(将`esp`指针移至现`ebp`)

`movl %ebp, %esp`

    参数3：
    参数2：  
    参数1：   
    返回地址：  
    %ebp                      <----ebp    <----esp   
    | 
    |

弹出`ebp`的旧值装入现在`ebp`中

`popl %ebp`

    参数3：
    参数2：  
    参数1：
    返回地址：                <----esp
    | 
    | 
    |

`ret`指令通过把返回地址从堆栈中弹出到程序计数器，从而从该函数返回

`ret`

## 实例

一个计算`2^3+5^2`的程序，定义了函数power

``` Asm
# in order to: show the function that can get the ans of x**n how work
#              and get the result of 2**3+5**2
#
#
# variable: all variable in register, so .data is null
#           
    
    .section .data

    .section .text

    .globl _start

_start:
    pushl $3                  # push the secondary parameter
    pushl $2                  # push the first parameter

    call power                # 

    addl $8, %esp             # stack pointer move afterwards

    pushl %eax                # esp+8 save the first result from eax

    pushl $2                  # push the secondary parameter
    pushl $5                  # push the first parameter

    call power

    addl $8, %esp             # stack pointer move afterwards

    popl %ebx                 # pop the first result to ebx
                              # and the secondary result has in eax

    addl %eax, %ebx           # ebx = eax + ebx

    movl $1, %eax             # '1' is the linux system call exit() code
                              # ebx save the number to back 
    int $0x80          

#
# in order to: function to get the result of x**n
#
# input: first parameter - n
#        secondary parameter - x
#
# outut: getback variable in %eax
#
# variable: %ebx - x
#           %ecx - 3
#
#           -4(%ebp) -  save current number
#           %eax - save temp number

    .type power, @function
power:
    pushl %ebp                # save the old base pointer
    movl %esp, %ebp           # set base pointer to stack pointer 
    subl $4, %esp             # save space for locat save 
                              #       
                              # n              <--12(%ebp) 
                              # x              <--8(%ebp)
                              # backadress     
                              # oldebp         <--(%ebp)
    movl 8(%ebp), %ebx        # x              <--(%esp) -4(%ebp)
    movl 12(%ebp), %ecx       # 

    movl %ebx, -4(%ebp)       # save current result

power_loop_start:
    cmpl $1, %ecx             # 
    je end_power              #
    movl -4(%ebp), %eax       #
    imull %ebx, %eax          #
    movl %eax, -4(%ebp)       #

    decl %ecx                 # ecx-=1
    jmp power_loop_start      #

end_power:
    movl -4(%ebp), %eax       # backnumber in %eax 
    mov %ebp, %esp            #
    popl %ebp                 # 
    ret                       #
```
