---
layout: post 
title: c 与汇编程序的约定调用
categories: [linux]
tags: [c, asm]
---

## 说明

### 1.执行函数前（已经调用）(prologue)：

将参数逆序压人堆栈(因为要使用esp加偏移量来访问参数，访问参数时可以不考虑参数的数量，直接用%esp+8(,%esp+12...)等访问第1个至第N个参数)

<code>pushl $3                  # push the n  parameter</code>

<code>pushl $2                  # push the secondary parameter</code>

<code>pushl $1                  # push the first parameter</code>

<code>call fun                  # </code>
    
    参数n
    .
    .
    .
    参数(3)：
    参数(2)：  
    参数(1)：  
    返回地址：                  <----esp 


### 2. 执行函数(body)：

<code>pushl %ebp</code>

保存原来的ebp

    .
    参数3：
    参数2：  
    参数1：
    返回地址：
    %ebp(原)                    <----esp

<code>movl %esp,%ebp</code>

    参数3：
    参数2：
    参数1：      
    返回地址：                                            
    %ebp(原)                    <----esp  <----ebp

<code>subl $8,%esp</code>

创建空间用于保存局部变量

    参数3：
    参数2：     
    参数1：           
    返回地址：            
    %ebp(原)                    <----ebp        
    |  
    |                           <----esp

### 3.返回(epilogue)：

<code>movl -n(%ebp), %eax</code>

保存返回值

<code>movl %ebp, %esp</code>

    参数3：
    参数2：  
    参数1：   
    返回地址：  
    %ebp                      <----ebp    <----esp   
    | 
    |

<code>popl %ebp</code>

弹出esp的旧值装入esp中

    参数3：
    参数2：  
    参数1：
    返回地址：                <----esp
    | 
    | 
    |

<code>ret</code>

ret指令通过把返回地址从堆栈中弹出到程序计数器，从而从该函数返回

## 实例

一个计算2**3+5**2的程序，定义了函数power

    # in order to: show the function that can get the ans of x**n how work
    #              and get the result of 2**3+5**2
    #
    #
    # variable: all variable in register, so .data is null
    #           
        
        .section .data
    
        .section .text
    
        .globl _start
    
    _start:
        pushl $3                  # push the secondary parameter
        pushl $2                  # push the first parameter
    
        call power                # 
    
        addl $8, %esp             # stack pointer move afterwards
    
        pushl %eax                # esp+8 save the first result from eax
    
        pushl $2                  # push the secondary parameter
        pushl $5                  # push the first parameter
    
        call power
    
        addl $8, %esp             # stack pointer move afterwards
    
        popl %ebx                 # pop the first result to ebx
                                  # and the secondary result has in eax
    
        addl %eax, %ebx           # ebx = eax + ebx
    
        movl $1, %eax             # '1' is the linux system call exit() code
                                  # ebx save the number to back 
        int $0x80          
    
    #
    # in order to: function to get the result of x**n
    #
    # input: first parameter - n
    #        secondary parameter - x
    #
    # outut: getback variable in %eax
    #
    # variable: %ebx - x
    #           %ecx - 3
    #
    #           -4(%ebp) -  save current number
    #           %eax - save temp number
    
        .type power, @function
    power:
        pushl %ebp                # save the old base pointer
        movl %esp, %ebp           # set base pointer to stack pointer 
        subl $4, %esp             # save space for locat save 
                                  #       
                                  # n              <--12(%ebp) 
                                  # x              <--8(%ebp)
                                  # backadress     
                                  # oldebp         <--(%ebp)
        movl 8(%ebp), %ebx        # x              <--(%esp) -4(%ebp)
        movl 12(%ebp), %ecx       # 
    
        movl %ebx, -4(%ebp)       # save current result
    
    power_loop_start:
        cmpl $1, %ecx             # 
        je end_power              #
        movl -4(%ebp), %eax       #
        imull %ebx, %eax          #
        movl %eax, -4(%ebp)       #
    
        decl %ecx                 # ecx-=1
        jmp power_loop_start      #
    
    end_power:
        movl -4(%ebp), %eax       # backnumber in %eax 
        mov %ebp, %esp            #
        popl %ebp                 # 
        ret                       #
