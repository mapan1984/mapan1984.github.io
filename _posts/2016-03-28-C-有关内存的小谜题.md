---
layout: post 
title: c 有关内存的谜题
categories: [linux]
tags: [c, bolg]
---

**1.破坏计数：**

{% highlight c linenos %}
    int main()
    {
        int i;
        int array[4];
        for(i=0;i<=4;i++){
            array[i] = 0;
        }
        return 0;
    }
{% endhighlight %}

堆栈中:

- | sava pc
- | i  *(即array 4)*
- | array 3
- | array 2
- | array 1
- | array 0

当i到达4时，"array[4]=0"会将i置换为0，所以会无限迭代

**2.重置返回地址：**

{% highlight c linenos %}
    int foo()
    {
        int array[4];
        int i;
        for(i=0;i<=4;i++){
            array[i] -= 4;
        }
        return 0;
    }
{% endhighlight %}

堆栈中：

- | save pc *(即array + 4)*

- | array + 3

- | array + 2

- | array + 1

- | array + 0

- | i

每次迭代的array + 4，即save pc处，将返回地址减4，又会再次调用此函数，从而无限迭代

**3.重用堆栈**

{% highlight c linenos %}
    int main()
    {
        newIntArray();
        printArray();
        return 0;
    }
    
    void newIntArray()
    {
        int array(100);
        for(int i = 0; i < 100; i++)
            array[i] = i; 
    }  
    
    void printArray()
    {
        int array[100];
        for(int i = 0; i < 100; i++)
            print("%d，", array[i]);
    }
{% endhighlight %}

输出结果：1，2，3，4，5，6，7， ...........100,    
堆栈中:

- | save pc

- | array 99

- | array 98

- | array 97

- | ..........

- | array 1

- | array 0

即newIntArray()在堆栈中创建数据后，printArray()又一次重新使用同一堆栈

